using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using MyMathFunctions;

namespace _061_Cyclical_figurate_numbers
{
    internal class Program
    {
        private static void Main()
        {
            //Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers 
            //are all figurate (polygonal) numbers and are generated by the following formulae:
            //Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
            //Square 	  	P4,n=n2 	  	1, 4, 9, 16, 25, ...
            //Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
            //Hexagonal 	  	P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
            //Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
            //Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...

            //The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

            //    The set is cyclic, in that the last two digits of each number is the first two digits of the next number 
            //    (including the last number with the first).
            //    Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), 
            //    is represented by a different number in the set.
            //    This is the only set of 4-digit numbers with this property.

            //Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: 
            //triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

            /*Notes:
             * 
             * each 4 digit number is made of two 2 digit numbers
             * 
             * each 2 digit number can't start or end with zero - otheriwse get leading zeroes problem
             * can't start or end and only 2 digits, so can't contain zero
             * 
             */

            var watch = Stopwatch.StartNew();


            int[] sixCyclicSet = SixCyclic4DigitNums();
            Console.WriteLine("Which sum to {0}\n", sixCyclicSet.Sum());


            watch.Stop();
            var elapsedMs = watch.ElapsedMilliseconds;
            Console.WriteLine("{0} ms ellapsed", elapsedMs);

            Console.Read();
        }

        private static int[] SixCyclic4DigitNums()
        {
            const int twoDigitStart = 11;
            const int twoDigitEnd = 99;
            List<int> twoDigitBases = Enumerable.Range(twoDigitStart, twoDigitEnd - twoDigitStart).ToList();
            twoDigitBases = twoDigitBases.Where(n => !n.ToString().Contains("0")).ToList();

            foreach (int n1 in twoDigitBases)
            {
                foreach (int n2 in twoDigitBases)
                {
                    var listToTest1 = new[]
                    {
                        n1,
                        n2
                    };
                    if (!MakesCyclicGeoNums(listToTest1)) continue;

                    foreach (int n3 in twoDigitBases)
                    {
                        var listToTest2 = new[]
                        {
                            n1,
                            n2,
                            n3
                        };
                        if (!MakesCyclicGeoNums(listToTest2)) continue;

                        foreach (int n4 in twoDigitBases)
                        {
                            var listToTest3 = new[]
                            {
                                n1,
                                n2,
                                n3,
                                n4
                            };
                            if (!MakesCyclicGeoNums(listToTest3)) continue;

                            foreach (int n5 in twoDigitBases)
                            {
                                var listToTest4 = new[]
                                {
                                    n1,
                                    n2,
                                    n3,
                                    n4,
                                    n5
                                };
                                if (!MakesCyclicGeoNums(listToTest4)) continue;

                                foreach (int n6 in twoDigitBases)
                                {
                                    var listToTest = new[]
                                    {
                                        n1,
                                        n2,
                                        n3,
                                        n4,
                                        n5,
                                        n6
                                    };
                                    int[] cyclicSet = MakeCyclicSet(listToTest);
                                    if (ContainsGeoTriThruOctUnique(cyclicSet))
                                    {
                                        PrintGeoType(cyclicSet);
                                        return cyclicSet;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return new[] {0};
        }

        private static int[] MakeCyclicSet(int[] numbers)
        {
            //8128, 2882, 8281
            //is made of 81, 28, 82

            var set = new int[numbers.Length];
            for (int i = 0; i < numbers.Length - 1; i++)
            {
                set[i] = ConcatNumbers(numbers[i], numbers[i + 1]);
            }
            set[set.Length - 1] = ConcatNumbers(numbers.Last(), numbers.First());
            return set;
        }

        private static int ConcatNumbers(int a, int b)
        {
            string sa = a.ToString();
            string sb = b.ToString();
            return int.Parse(sa + sb);
        }

        private static void PrintGeoType(int[] set)
        {
            foreach (int i in set)
            {
                Console.Write("{0} is ", i);
                if (MathFunctions.IsTriangular(i))
                {
                    Console.Write("Triangular ");
                }
                if (MathFunctions.IsSquare(i))
                {
                    Console.Write("Square ");
                }
                if (MathFunctions.IsPentagonal(i))
                {
                    Console.Write("Pentagonal ");
                }
                if (MathFunctions.IsHexagonal(i))
                {
                    Console.Write("Hexagonal ");
                }
                if (MathFunctions.IsHeptagonal(i))
                {
                    Console.Write("Heptagonal ");
                }
                if (MathFunctions.IsOctagonal(i))
                {
                    Console.Write("Octagonal ");
                }
                Console.WriteLine();
            }
        }

        private static List<GeoNumTypes> GetGeoTypes(int number)
        {
            var types = new List<GeoNumTypes>();
            if (MathFunctions.IsTriangular(number))
            {
                types.Add(GeoNumTypes.Triangular);
            }
            if (MathFunctions.IsSquare(number))
            {
                types.Add(GeoNumTypes.Square);
            }
            if (MathFunctions.IsPentagonal(number))
            {
                types.Add(GeoNumTypes.Pentagonal);
            }
            if (MathFunctions.IsHexagonal(number))
            {
                types.Add(GeoNumTypes.Hexagonal);
            }
            if (MathFunctions.IsHeptagonal(number))
            {
                types.Add(GeoNumTypes.Heptagonal);
            }
            if (MathFunctions.IsOctagonal(number))
            {
                types.Add(GeoNumTypes.Octagonal);
            }
            return types;
        }

        private static bool ContainsGeoTriThruOct(int[] set)
        {
            return set.Any(MathFunctions.IsTriangular)
                   && set.Any(MathFunctions.IsSquare)
                   && set.Any(MathFunctions.IsPentagonal)
                   && set.Any(MathFunctions.IsHexagonal)
                   && set.Any(MathFunctions.IsHeptagonal)
                   && set.Any(MathFunctions.IsOctagonal)
                   && set.All(IsGeoNum);
        }

        private static bool ContainsGeoTriThruOctUnique(int[] set)
        {
            if (!ContainsGeoTriThruOct(set))
            {
                return false;
            }

            var geoTypes = set.Select(GetGeoTypes).ToList();
            var geoNumTypesFound = new Dictionary<GeoNumTypes, bool>();
            geoNumTypesFound[GeoNumTypes.Triangular] = false;
            geoNumTypesFound[GeoNumTypes.Square] = false;
            geoNumTypesFound[GeoNumTypes.Pentagonal] = false;
            geoNumTypesFound[GeoNumTypes.Hexagonal] = false;
            geoNumTypesFound[GeoNumTypes.Heptagonal] = false;
            geoNumTypesFound[GeoNumTypes.Octagonal] = false;

            while (geoTypes.Any())
            {
                CheckForUniqueTypes(geoTypes, geoNumTypesFound);
            }

            return geoNumTypesFound.All(x => x.Value);
        }

        private static void CheckForUniqueTypes(List<List<GeoNumTypes>> geoTypes,
            Dictionary<GeoNumTypes, bool> geoNumTypesFound)
        {
            for (int i = 0; i < geoTypes.Count; i++)
            {
                List<GeoNumTypes> geoTypeList = geoTypes[i];
                if (geoTypeList.Count == 1)
                {
                    geoNumTypesFound[geoTypeList[0]] = true;
                    geoTypes.RemoveAt(i);
                    i--;
                }
            }
            foreach (var geoTypeList in geoTypes)
            {
                for (int i = 0; i < geoTypeList.Count; i++)
                {
                    if (geoNumTypesFound[geoTypeList[i]])
                    {
                        geoTypeList.RemoveAt(i);
                        i--;
                    }
                }
            }
            for (int i = 0; i < geoTypes.Count; i++)
            {
                if (!geoTypes[i].Any())
                {
                    geoTypes.RemoveAt(i);
                    i--;
                }
            }

            for (int i = 0; i < geoTypes.Count; i++)
            {
                List<GeoNumTypes> geoTypeList = geoTypes[i];
                if (geoTypeList.Count > 1)
                {
                    //if none of the geoTypes this number is have been found yet
                    if (geoTypeList.All(x => geoNumTypesFound[x] == false))
                    {
                        geoNumTypesFound[geoTypeList[0]] = true;
                        geoTypes.RemoveAt(i);
                        i--;
                    }
                }
            }
        }

        private static bool IsGeoNum(int n)
        {
            if (MathFunctions.IsTriangular(n)
                || MathFunctions.IsSquare(n)
                || MathFunctions.IsPentagonal(n)
                || MathFunctions.IsHexagonal(n)
                || MathFunctions.IsHeptagonal(n)
                || MathFunctions.IsOctagonal(n))
            {
                //PrintGeoType(Enumerable.Repeat(n, 1).ToArray());
                return true;
            }
            return false;
        }

        private static bool MakesCyclicGeoNums(int[] set)
        {
            int[] cyclicSet = MakeCyclicSet(set);
            //remove the last element as it will not be the end of the set yet
            cyclicSet = cyclicSet.Take(cyclicSet.Length - 1).ToArray();
            return cyclicSet.All(IsGeoNum);
        }

        private enum GeoNumTypes
        {
            Triangular,
            Square,
            Pentagonal,
            Hexagonal,
            Heptagonal,
            Octagonal
        }
    }
}